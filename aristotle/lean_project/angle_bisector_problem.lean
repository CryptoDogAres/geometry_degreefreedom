/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 86e2b544-c6c8-49e3-bca1-e4f015c16ba1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We prove the Angle Bisector Theorem.
The user's request "AB/AC=AD/DC" contains a typo (AD should be BD).
We prove the standard theorem: if AD bisects angle A and D is on BC, then AB/AC = BD/DC.

The proof proceeds by:
1. Establishing that D lies strictly between B and C (`sbtw_of_angle_bisector_intersect`).
2. Showing that sin(∠ADB) = sin(∠ADC) because the angles are supplementary (`sin_angle_eq_sin_angle_of_sbtw`).
3. Applying the Law of Sines to triangles ABD and ACD.
   - In ABD: BD / sin(A/2) = AB / sin(∠ADB)
   - In ACD: DC / sin(A/2) = AC / sin(∠ADC)
4. Dividing these equations and using the equality of sines gives the result.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
In a non-degenerate triangle ABC, if D is the intersection of the angle bisector of A with the segment BC, then D is strictly between B and C.
-/
open EuclideanGeometry Metric

variable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]

lemma sbtw_of_angle_bisector_intersect (A B C D : P)
  (h_triangle : ¬ Collinear ℝ {A, B, C})
  (h_D_on_BC : D ∈ affineSegment ℝ B C)
  (h_bisector : angle B A D = angle C A D) :
  Sbtw ℝ B D C := by
  -- By contradiction, assume $D = B$.
  by_cases hDB : D = B;
  · simp_all +decide [ EuclideanGeometry.angle ];
    rw [ InnerProductGeometry.angle_self ] at h_bisector;
    · rw [ eq_comm, InnerProductGeometry.angle_eq_zero_iff ] at h_bisector;
      refine' h_triangle _;
      rw [ collinear_iff_exists_forall_eq_smul_vadd ];
      use A, C -ᵥ A;
      simp +zetaDelta at *;
      exact ⟨ ⟨ 0, by simp +decide ⟩, ⟨ h_bisector.2.choose, by rw [ ← h_bisector.2.choose_spec.2, vsub_vadd ] ⟩, ⟨ 1, by simp +decide ⟩ ⟩;
    · exact vsub_ne_zero.mpr ( by rintro rfl; exact h_triangle <| by simp +decide [ collinear_pair ] );
  · by_cases hDC : D = C <;> simp_all +decide [ Sbtw ];
    · simp_all +decide [ EuclideanGeometry.angle ];
      rw [ InnerProductGeometry.angle_self ] at h_bisector;
      · rw [ InnerProductGeometry.angle_eq_zero_iff ] at h_bisector;
        refine' h_triangle _;
        rw [ collinear_iff_exists_forall_eq_smul_vadd ];
        exact ⟨ A, B -ᵥ A, fun p hp => by rcases hp with ( rfl | rfl | rfl ) <;> [ exact ⟨ 0, by simp +decide ⟩ ; exact ⟨ 1, by simp +decide ⟩ ; exact ⟨ h_bisector.2.choose, by rw [ ← h_bisector.2.choose_spec.2, vsub_vadd ] ⟩ ] ⟩;
      · simp_all +decide [ sub_eq_zero ];
        rintro rfl; simp_all +decide [ collinear_pair ];
    · exact?

/-
If D is strictly between B and C, then sin(angle ADB) = sin(angle ADC).
-/
open EuclideanGeometry Metric

variable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]

lemma sin_angle_eq_sin_angle_of_sbtw (A B C D : P) (h : Sbtw ℝ B D C) :
  Real.sin (angle A D B) = Real.sin (angle A D C) := by
  -- By the properties of angles in a triangle, we know that angle BDC = π.
  have h_angle_BDC : angle B D C = Real.pi := by
    exact?;
  -- By the properties of angles in a triangle, we know that angle ADB + angle ADC = π.
  have h_angle_sum : angle A D B + angle A D C = Real.pi := by
    exact?;
  rw [ ← Real.sin_pi_sub, ← h_angle_sum, add_sub_cancel_left ]

/-
The Angle Bisector Theorem: In a triangle ABC, if the bisector of angle A intersects the segment BC at D, then AB/AC = BD/DC.
-/
open EuclideanGeometry Metric

variable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]

theorem angle_bisector_theorem_corrected (A B C D : P)
  (h_triangle : ¬ Collinear ℝ {A, B, C})
  (h_D_on_BC : D ∈ affineSegment ℝ B C)
  (h_bisector : angle B A D = angle C A D) :
  dist A B / dist A C = dist B D / dist D C := by
  -- By definition of angle bisector, we know that $A B / A C = B D / D C$.
  have h_angle_bisector : Real.sin (angle B A D) / dist B D = Real.sin (angle A D B) / dist A B ∧ Real.sin (angle C A D) / dist D C = Real.sin (angle A D C) / dist A C := by
    apply And.intro;
    · convert EuclideanGeometry.sin_angle_div_dist_eq_sin_angle_div_dist _ _ using 1;
      congr! 1;
      · exact dist_comm _ _;
      · rw [ EuclideanGeometry.sin_angle_div_dist_eq_sin_angle_div_dist ];
        · rw [ dist_comm ];
        · rintro rfl; simp_all +decide [ collinear_pair ];
        · rintro rfl;
          refine' h_triangle _;
          rw [ collinear_iff_exists_forall_eq_smul_vadd ];
          rcases h_D_on_BC with ⟨ r, hr, rfl ⟩;
          exact ⟨ B, C -ᵥ B, fun p hp => by rcases hp with ( rfl | rfl | rfl ) <;> [ exact ⟨ r, by simp +decide [ AffineMap.lineMap_apply ] ⟩ ; exact ⟨ 0, by simp +decide ⟩ ; exact ⟨ 1, by simp +decide ⟩ ] ⟩;
      · rintro rfl;
        refine' h_triangle _;
        rw [ collinear_iff_exists_forall_eq_smul_vadd ];
        obtain ⟨ r, hr ⟩ := h_D_on_BC;
        use B, C -ᵥ B;
        simp +decide [ ← hr.2, AffineMap.lineMap_apply ];
        exact ⟨ ⟨ r, rfl ⟩, ⟨ 0, by simp +decide ⟩, ⟨ 1, by simp +decide ⟩ ⟩;
      · rintro rfl;
        simp_all +decide [ EuclideanGeometry.angle ];
        rw [ InnerProductGeometry.angle_self ] at h_bisector;
        · rw [ eq_comm, InnerProductGeometry.angle_eq_zero_iff ] at h_bisector;
          refine' h_triangle _;
          rw [ collinear_iff_exists_forall_eq_smul_vadd ];
          use A, C -ᵥ A;
          simp +zetaDelta at *;
          exact ⟨ ⟨ 0, by simp +decide ⟩, ⟨ h_bisector.2.choose, by rw [ ← h_bisector.2.choose_spec.2, vsub_vadd ] ⟩, ⟨ 1, by simp +decide ⟩ ⟩;
        · intro h; simp_all +decide [ sub_eq_zero ];
          exact h_triangle ( collinear_pair ℝ A C );
    · convert EuclideanGeometry.sin_angle_div_dist_eq_sin_angle_div_dist _ _ using 1;
      · rw [ EuclideanGeometry.sin_angle_div_dist_eq_sin_angle_div_dist ];
        · rw [ dist_comm C A ];
        · rintro rfl; simp_all +decide [ collinear_pair ];
        · rintro rfl;
          refine' h_triangle _;
          rw [ collinear_iff_exists_forall_eq_smul_vadd ];
          rcases h_D_on_BC with ⟨ r, hr, rfl ⟩;
          exact ⟨ B, C -ᵥ B, fun p hp => by rcases hp with ( rfl | rfl | rfl ) <;> [ exact ⟨ r, by simp +decide [ AffineMap.lineMap_apply ] ⟩ ; exact ⟨ 0, by simp +decide ⟩ ; exact ⟨ 1, by simp +decide ⟩ ] ⟩;
      · rintro rfl;
        refine' h_triangle _;
        rw [ collinear_iff_exists_forall_eq_smul_vadd ];
        rcases h_D_on_BC with ⟨ r, hr, rfl ⟩;
        exact ⟨ B, C -ᵥ B, fun p hp => by rcases hp with ( rfl | rfl | rfl ) <;> [ exact ⟨ r, by simp +decide [ AffineMap.lineMap_apply ] ⟩ ; exact ⟨ 0, by simp +decide ⟩ ; exact ⟨ 1, by simp +decide ⟩ ] ⟩;
      · rintro rfl;
        simp_all +decide [ EuclideanGeometry.angle ];
        rw [ InnerProductGeometry.angle_self ] at h_bisector;
        · rw [ InnerProductGeometry.angle_eq_zero_iff ] at h_bisector;
          refine' h_triangle _;
          rw [ collinear_iff_exists_forall_eq_smul_vadd ];
          exact ⟨ A, B -ᵥ A, fun p hp => by rcases hp with ( rfl | rfl | rfl ) <;> [ exact ⟨ 0, by simp +decide ⟩ ; exact ⟨ 1, by simp +decide ⟩ ; exact ⟨ h_bisector.2.choose, by rw [ ← h_bisector.2.choose_spec.2, vsub_vadd ] ⟩ ] ⟩;
        · exact vsub_ne_zero.mpr ( by rintro rfl; simp_all +decide [ collinear_pair ] );
  -- Since $\sin(\angle A D B) = \sin(\angle A D C)$, we can equate the two expressions from the Angle Bisector Theorem.
  have h_sin_eq' : Real.sin (angle A D B) = Real.sin (angle A D C) := by
    apply sin_angle_eq_sin_angle_of_sbtw;
    exact?;
  by_cases hAB : dist A B = 0 <;> by_cases hAC : dist A C = 0 <;> simp_all +decide [ div_eq_mul_inv ];
  · exact False.elim ( h_triangle <| collinear_pair ℝ _ _ );
  · exact Or.inr ( h_angle_bisector.2.resolve_left ( by norm_num [ mul_div ] ) );
  · by_cases hBD : dist B D = 0 <;> by_cases hDC : dist D C = 0 <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
    have h_sin_ne_zero : Real.sin (angle C A D) ≠ 0 := by
      intro h_sin_zero_triangle; simp_all +decide [ EuclideanGeometry.angle ] ;
      rw [ Real.sin_eq_zero_iff_of_lt_of_lt ] at h_sin_zero_triangle <;> try linarith [ Real.pi_pos, InnerProductGeometry.angle_nonneg ( C -ᵥ A ) ( D -ᵥ A ), InnerProductGeometry.angle_le_pi ( C -ᵥ A ) ( D -ᵥ A ) ] ;
      · rw [ InnerProductGeometry.angle_eq_zero_iff ] at h_sin_zero_triangle;
        obtain ⟨ r, hr, hr' ⟩ := h_sin_zero_triangle.2; simp_all +decide [ sub_eq_iff_eq_add ] ;
        rw [ InnerProductGeometry.angle_eq_zero_iff ] at h_bisector ; simp_all +decide [ sub_eq_iff_eq_add ] ;
        obtain ⟨ s, hs, hs' ⟩ := h_bisector.2; simp_all +decide [ collinear_pair ] ;
        refine' h_triangle _;
        rw [ collinear_iff_exists_forall_eq_smul_vadd ] ; use A ; simp +decide [ hs', hr' ];
        exact ⟨ B -ᵥ A, ⟨ 0, by simp +decide ⟩, ⟨ 1, by simp +decide ⟩, ⟨ s, by rw [ ← hs', vsub_vadd ] ⟩ ⟩;
      · refine' lt_of_le_of_ne ( InnerProductGeometry.angle_le_pi _ _ ) _;
        intro h; simp_all +decide [ InnerProductGeometry.angle_eq_pi_iff ] ;
        obtain ⟨ r, hr, hr' ⟩ := h.2;
        obtain ⟨ s, hs, hs' ⟩ := h_bisector.2;
        -- Since $r < 0$ and $s < 0$, we have $r • (C -ᵥ A) = s • (B -ᵥ A)$ implies $C -ᵥ A = \frac{s}{r} • (B -ᵥ A)$.
        have h_eq : C -ᵥ A = (s / r) • (B -ᵥ A) := by
          simp_all +decide [ div_eq_inv_mul, MulAction.mul_smul ];
          rw [ inv_smul_smul₀ ( ne_of_lt hr ) ];
        refine' h_triangle _;
        rw [ collinear_iff_exists_forall_eq_smul_vadd ];
        use A, B -ᵥ A;
        simp +decide [ h_eq ];
        exact ⟨ ⟨ 0, by simp +decide ⟩, ⟨ 1, by simp +decide ⟩, ⟨ s / r, by rw [ ← h_eq, vsub_vadd ] ⟩ ⟩;
    simp_all +decide [ ← div_eq_inv_mul ];
    rw [ div_eq_div_iff ] at h_angle_bisector <;> simp_all +decide [ dist_comm ];
    grind

/-
The Angle Bisector Theorem: In a triangle ABC, if the bisector of angle A intersects the segment BC at D, then AB/AC = BD/DC.
-/
open EuclideanGeometry Metric

variable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P]

theorem angle_bisector_theorem_final (A B C D : P)
  (h_triangle : ¬ Collinear ℝ {A, B, C})
  (h_D_on_BC : D ∈ affineSegment ℝ B C)
  (h_bisector : angle B A D = angle C A D) :
  dist A B / dist A C = dist B D / dist D C := by
  exact?